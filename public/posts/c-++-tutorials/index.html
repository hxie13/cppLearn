<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Array learning | Shui Lian Cave</title>

    



<meta name="author" content="LBXX2020" />
<meta name="description" content="1. C&#43;&#43; Primer  1.1. 第1章 开始  1.1.1. 编写一个简单的C&#43;&#43;程序  1.1.1.1. 编译、运行程序   1.1.2. 节练习 1.1.3. 初识输入输出 1.1.4. 注释简介 1.1.5. 控制流  1.1.5.1. while 语句 1.1.5.2. for 语句 1.1.5.3. 读取不定量的输入数据 1.1.5.4. if 语句   1.1.6. 类简介     2. 数据结构  2.1. Arrays  2.1.1. :pencil2: 补充说明 1 2.1.2. :books: 数组操作 2.1.3. :books: Initializing arrays 2.1.4. :pencil2: 补充说明 2 2.1.5. :books: Multidimensional arrays 2.1.6. 二维数组 2." />



<meta name="generator" content="Hugo 0.80.0" />

<link rel="canonical" href="https://hxie13.github.io/cppLearn/posts/c-&#43;&#43;-tutorials/" />


<meta property="og:title" content="Array learning" />
<meta property="og:description" content="1. C&#43;&#43; Primer  1.1. 第1章 开始  1.1.1. 编写一个简单的C&#43;&#43;程序  1.1.1.1. 编译、运行程序   1.1.2. 节练习 1.1.3. 初识输入输出 1.1.4. 注释简介 1.1.5. 控制流  1.1.5.1. while 语句 1.1.5.2. for 语句 1.1.5.3. 读取不定量的输入数据 1.1.5.4. if 语句   1.1.6. 类简介     2. 数据结构  2.1. Arrays  2.1.1. :pencil2: 补充说明 1 2.1.2. :books: 数组操作 2.1.3. :books: Initializing arrays 2.1.4. :pencil2: 补充说明 2 2.1.5. :books: Multidimensional arrays 2.1.6. 二维数组 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://hxie13.github.io/cppLearn/posts/c-&#43;&#43;-tutorials/" />
<meta property="article:published_time" content="2021-02-07T11:23:33+08:00" />
<meta property="article:modified_time" content="2021-02-07T11:23:33+08:00" />



<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Array learning"/>
<meta name="twitter:description" content="1. C&#43;&#43; Primer  1.1. 第1章 开始  1.1.1. 编写一个简单的C&#43;&#43;程序  1.1.1.1. 编译、运行程序   1.1.2. 节练习 1.1.3. 初识输入输出 1.1.4. 注释简介 1.1.5. 控制流  1.1.5.1. while 语句 1.1.5.2. for 语句 1.1.5.3. 读取不定量的输入数据 1.1.5.4. if 语句   1.1.6. 类简介     2. 数据结构  2.1. Arrays  2.1.1. :pencil2: 补充说明 1 2.1.2. :books: 数组操作 2.1.3. :books: Initializing arrays 2.1.4. :pencil2: 补充说明 2 2.1.5. :books: Multidimensional arrays 2.1.6. 二维数组 2."/>


<link rel="stylesheet" href="/cppLearn/css/semantic.min.css" />
<link rel="stylesheet" href="/cppLearn/css/icomoon.css" />
<link rel="stylesheet" href="/cppLearn/css/OverlayScrollbars.min.css" />
<link rel="stylesheet" href="/cppLearn/css/github-markdown.css" />
<link rel="stylesheet" href="/cppLearn/css/site.css" />

<style>
  a:not(.ui.button):hover {
    text-decoration: underline;
  }

  
  a:not(.ui.button) {
    color: seagreen !important;
  }
  

  

  
  body.default {
    
    background-color: #f7f7f7;
    

    
  }
  

  
</style>


    







    
  </head>

  <body class="default">
    
<nav class="ui secondary menu dream-menu">

  <div class="item">
    <i class="large link bullseye icon dream-flip-toggle" title="Flip it!"></i>
  </div>
  <div class="item">
    <i class="large link home icon" title="Home" onclick="window.location.href = 'https:\/\/hxie13.github.io\/cppLearn'"></i>
  </div>
  
  
</nav>

    <div class="flip-container">
      <div class="flipper">
        <section class="front">
          <div class="dream-max-width">
            
<div class="ui relaxed grid dream-grid">
  <aside class="sixteen wide mobile sixteen wide tablet four wide computer column dream-single-aside">
    
    
    <div class="ui segment toc">
      <nav id="TableOfContents">
  <ul>
    <li><a href="#11-第1章-开始">1.1. 第1章 开始</a>
      <ul>
        <li><a href="#111-编写一个简单的c程序">1.1.1. 编写一个简单的C++程序</a></li>
        <li><a href="#112-节练习">1.1.2. 节练习</a></li>
        <li><a href="#113-初识输入输出">1.1.3. 初识输入输出</a></li>
        <li><a href="#114-注释简介">1.1.4. 注释简介</a></li>
        <li><a href="#115-控制流">1.1.5. 控制流</a></li>
        <li><a href="#116-类简介">1.1.6. 类简介</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#21-arrays">2.1. Arrays</a>
      <ul>
        <li><a href="#211-pencil2-补充说明-1">2.1.1. :pencil2: 补充说明 1</a></li>
        <li><a href="#212-books-数组操作">2.1.2. :books: 数组操作</a></li>
        <li><a href="#213-books-initializing-arrays">2.1.3. :books: Initializing arrays</a></li>
        <li><a href="#214-pencil2-补充说明-2">2.1.4. :pencil2: 补充说明 2</a></li>
        <li><a href="#215-books-multidimensional-arrays">2.1.5. :books: Multidimensional arrays</a></li>
        <li><a href="#216-二维数组">2.1.6. 二维数组</a></li>
        <li><a href="#217-books-arrays-as-parameters">2.1.7. :books: Arrays as parameters</a></li>
        <li><a href="#218-books-library-arrays">2.1.8. :books: Library arrays</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#31-vector">3.1. Vector</a>
      <ul>
        <li><a href="#311-initialize">3.1.1. Initialize</a></li>
        <li><a href="#312-迭代器遍历器-iterator">3.1.2. 迭代器(遍历器) Iterator</a></li>
        <li><a href="#313-基本操作">3.1.3. 基本操作</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#41-pointers">4.1. Pointers</a>
      <ul>
        <li><a href="#411-books-address-of-operator">4.1.1. :books: Address-of operator(&amp;)</a></li>
        <li><a href="#412-books-dereference-operator">4.1.2. :books: Dereference operator(*)</a></li>
      </ul>
    </li>
    <li><a href="#42-class">4.2. Class</a></li>
  </ul>

  <ul>
    <li><a href="#51-sort">5.1. sort</a></li>
    <li><a href="#52-binary-search">5.2. Binary search</a>
      <ul>
        <li><a href="#521-常用场景">5.2.1. 常用场景</a></li>
        <li><a href="#522-框架">5.2.2. 框架</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#61-数组">6.1. 数组</a>
      <ul>
        <li><a href="#611-寻找中心索引">6.1.1. 寻找中心索引</a></li>
        <li><a href="#612-搜索插入位置">6.1.2. 搜索插入位置</a></li>
        <li><a href="#613-合并区间">6.1.3. 合并区间</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </div>
    
    <div class="ui segment actions">
      <button
        class="ui circular icon button save-as-image"
        title="Save as image"
        onclick="savePostAsImg()">
        <i class="save icon"></i>
      </button>

      <a href="https://twitter.com/intent/tweet?text=Array%20learning&url=https%3a%2f%2fhxie13.github.io%2fcppLearn%2fposts%2fc-%2b%2b-tutorials%2f" class="ui circular twitter icon button">
  <i class="twitter icon"></i>
</a>
<a href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fhxie13.github.io%2fcppLearn%2fposts%2fc-%2b%2b-tutorials%2f" class="ui circular facebook icon button">
  <i class="facebook icon"></i>
</a>

    </div>
  </aside>
  <div class="sixteen wide mobile sixteen wide tablet twelve wide computer column markdown-body dream-single" id="dream-save-post-as-img">
    
    <section class="ui top attached segment">
      <header>
        <h1 class="ui large header">Array learning<div class="sub header">
            @
            
              LBXX2020
            

            | 
                Sunday, Feb 7, 2021
              

            | 5 minutes read

            | Update at
              
                Sunday, Feb 7, 2021
              
          </div>
        </h1>
      </header>

      <article class="main"><!-- raw HTML omitted -->
<ul>
<li><a href="#1-c-primer">1. C++ Primer</a>
<ul>
<li><a href="#11-%E7%AC%AC1%E7%AB%A0-%E5%BC%80%E5%A7%8B">1.1. 第1章 开始</a>
<ul>
<li><a href="#111-%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84c%E7%A8%8B%E5%BA%8F">1.1.1. 编写一个简单的C++程序</a>
<ul>
<li><a href="#1111-%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F">1.1.1.1. 编译、运行程序</a></li>
</ul>
</li>
<li><a href="#112-%E8%8A%82%E7%BB%83%E4%B9%A0">1.1.2. 节练习</a></li>
<li><a href="#113-%E5%88%9D%E8%AF%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA">1.1.3. 初识输入输出</a></li>
<li><a href="#114-%E6%B3%A8%E9%87%8A%E7%AE%80%E4%BB%8B">1.1.4. 注释简介</a></li>
<li><a href="#115-%E6%8E%A7%E5%88%B6%E6%B5%81">1.1.5. 控制流</a>
<ul>
<li><a href="#1151-while-%E8%AF%AD%E5%8F%A5">1.1.5.1. <strong>while</strong> 语句</a></li>
<li><a href="#1152-for-%E8%AF%AD%E5%8F%A5">1.1.5.2. <strong>for</strong> 语句</a></li>
<li><a href="#1153-%E8%AF%BB%E5%8F%96%E4%B8%8D%E5%AE%9A%E9%87%8F%E7%9A%84%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE">1.1.5.3. 读取不定量的输入数据</a></li>
<li><a href="#1154-if-%E8%AF%AD%E5%8F%A5">1.1.5.4. <strong>if</strong> 语句</a></li>
</ul>
</li>
<li><a href="#116-%E7%B1%BB%E7%AE%80%E4%BB%8B">1.1.6. 类简介</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">2. 数据结构</a>
<ul>
<li><a href="#21-arrays">2.1. Arrays</a>
<ul>
<li><a href="#211-pencil2-%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E-1">2.1.1. ✏️ 补充说明 1</a></li>
<li><a href="#212-books-%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C">2.1.2. 📚 数组操作</a></li>
<li><a href="#213-books-initializing-arrays">2.1.3. 📚 Initializing arrays</a></li>
<li><a href="#214-pencil2-%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E-2">2.1.4. ✏️ 补充说明 2</a></li>
<li><a href="#215-books-multidimensional-arrays">2.1.5. 📚 Multidimensional arrays</a></li>
<li><a href="#216-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84">2.1.6. 二维数组</a></li>
<li><a href="#217-books-arrays-as-parameters">2.1.7. 📚 Arrays as parameters</a></li>
<li><a href="#218-books-library-arrays">2.1.8. 📚 Library arrays</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-stl---standard-template-library">3. STL&mdash;standard template library</a>
<ul>
<li><a href="#31-vector">3.1. Vector</a>
<ul>
<li><a href="#311-initialize">3.1.1. Initialize</a></li>
<li><a href="#312-%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%81%8D%E5%8E%86%E5%99%A8-iterator">3.1.2. 迭代器(遍历器) Iterator</a></li>
<li><a href="#313-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">3.1.3. 基本操作</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-%E8%AF%AD%E6%B3%95">4. 语法</a>
<ul>
<li><a href="#41-pointers">4.1. Pointers</a>
<ul>
<li><a href="#411-books-address-of-operator">4.1.1. 📚 Address-of operator(&amp;)</a></li>
<li><a href="#412-books-dereference-operator">4.1.2. 📚 Dereference operator(*)</a></li>
</ul>
</li>
<li><a href="#42-class">4.2. Class</a></li>
<li><a href="#--%E7%B1%BB%E5%86%85%E4%B8%8D%E5%9C%A8%E9%99%90%E5%AE%9A%E7%AC%A6%E4%B8%8B%E5%A3%B0%E6%98%8E%E7%9A%84%E6%88%90%E5%91%98%E9%BB%98%E8%AE%A4%E6%98%AFprivate-access">- 类内不在限定符下声明的成员默认是private access.</a></li>
</ul>
</li>
<li><a href="#5-%E7%AE%97%E6%B3%95">5. 算法</a>
<ul>
<li><a href="#51-sort">5.1. sort</a></li>
<li><a href="#52-binary-search">5.2. Binary search</a>
<ul>
<li><a href="#521-%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF">5.2.1. 常用场景</a></li>
<li><a href="#522-%E6%A1%86%E6%9E%B6">5.2.2. 框架</a>
<ul>
<li><a href="#5221-%E5%AF%BB%E6%89%BE%E4%B8%80%E4%B8%AA%E6%95%B0">5.2.2.1. 寻找一个数</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#6-%E5%88%B7%E9%A2%98">6. 刷题</a>
<ul>
<li><a href="#61-%E6%95%B0%E7%BB%84">6.1. 数组</a>
<ul>
<li><a href="#611-%E5%AF%BB%E6%89%BE%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95">6.1.1. 寻找中心索引</a></li>
<li><a href="#612-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE">6.1.2. 搜索插入位置</a></li>
<li><a href="#613-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4">6.1.3. 合并区间</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<h1 id="1-c-primer">1. C++ Primer</h1>
<h2 id="11-第1章-开始">1.1. 第1章 开始</h2>
<h3 id="111-编写一个简单的c程序">1.1.1. 编写一个简单的C++程序</h3>
<p>语句<code>statement</code>，声明<code>declaration</code>，初始化<code>initialize</code></p>
<ul>
<li>每个C++程序必须包含<strong>main</strong>函数，操作系统通过调用<strong>main</strong>来运行C++程序.</li>
<li>函数定义包括四部分：返回类型，函数名，形参列表，函数体.</li>
<li><code>int</code>类型是一种内置类型，即语言自身定义的类型.</li>
<li>类型不仅定义了数据元素的内容，还定义了这类数据上可以进行的运算.</li>
</ul>
<h4 id="1111-编译运行程序">1.1.1.1. 编译、运行程序</h4>
<p>程序编写后需要编译它，这一过程依赖于操作系统和编译器.</p>
<ul>
<li>编译器要求源码存储在一个或多个源文件中，源文件命名以(名字.后缀)组合.</li>
<li>命令行运行编译器，命令如<strong>例1.1.1.1</strong>，Windows系统下，编译器生成可执行文件，命名为<code>prog1.exe</code>；UNIX系统下，编译器将可执行文件命名为<code>a.out</code>.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">/* 例1.1.1.1 */</span>
<span style="color:#960050;background-color:#1e0010">$</span> CC prog1.cc   <span style="color:#75715e">// CC是编译器名字，.cc是源文件后缀
</span></code></pre></div><ul>
<li>在Windows下运行可执行性文件，可键入<code>$ .\prog1</code>，&quot;.&ldquo;后跟反斜线指出该文件在当前目录中.</li>
<li>在UNIX系统下，需要使用全文件名，包括文件扩展名，<code>$ ./a.out</code>.</li>
<li>访问<strong>main</strong>的返回值，UNIX下可<code>$ echo $?</code>，Windows下可<code>$ echo %ERRORLEVEL%</code>，获得其返回值.</li>
<li>常用编译器有GNU编译器和微软Visual Studio编译器，我们学习中选择GNU编译器.默认情况下，运行GNU编译器的命令是<code>g++</code>:<code>$ g++ -o prog1 prog1.cc</code>,<code>-o prog1</code>是编译器参数，指定了可执行文件的文件名，UNIX下生成无后缀的<code>prog1</code>，Windows下生成<code>prog1.exe</code>.</li>
<li>根据GNU编译器的版本，可能需要指定<code>-std=c++0x</code>参数来打开对C++11的支持；此外，GNU编译器中使用<code>-Wall</code>选项，能对有问题的程序结构发出警告.</li>
</ul>
<h3 id="112-节练习">1.1.2. 节练习</h3>
<p>GNU编译器默认命令为<code>g++</code>，所使用的文件命名约定为<code>name.cpp(c++,cxx...)</code>.</p>
<h3 id="113-初识输入输出">1.1.3. 初识输入输出</h3>
<p>C++语言未定义任何输入输出(IO)语句，包含了一个全面的标准库来提供IO机制.所使用的<code>iostream</code>包含两个基础类型<code>istream</code>和<code>ostream</code>，分别表示输入流和输出流.</p>
<ul>
<li>&ldquo;流(<code>stream</code>)&ldquo;是指，随时间的推移，字符是顺序生成或消耗的.</li>
<li>标准库定义了4个IO对象，<code>istream</code>类型的<code>cin</code>对象；<code>ostream</code>类型的<code>cout</code>,<code>cerr</code>,<code>clog</code>对象.</li>
<li><code>#include</code>指令和头文件的名字必须写在同一行中，通常情况下，<code>#include</code>指令必须出现在所有函数之外.</li>
<li>表达式(<code>expression</code>)由一个或多个运算对象和运算符组成.</li>
<li>输出运算符<code>&lt;&lt;</code>接受两个运算对象，左侧运算对象必须是一个<code>ostream</code>对象，右侧运算对象是要打印的值，实现将给定的值写到给定的<code>ostream</code>对象中，输出运算符返回其左侧运算对象作为其计算结果，由此，多个输出运算符链接，能将前一次计算结果(<code>ostream</code>对象)作为第二个运算符的左侧运算对象.</li>
<li>字符串字面值常量(<code>string literal</code>)，是用双引号包围的字符序列.</li>
<li><code>endl</code>是一个操纵符(<code>manipulator</code>)，结束当前行，并将与设备关联的缓冲区(<code>buffer</code>)中的内容刷到设备中；缓冲刷新操作能保证目前为止程序产生的输出都真正写入输出流中，而不仅仅顶留在内存中等待写入流.</li>
<li>调试时，保持刷新流的输出，有利于程序崩溃时错误位置的推断.</li>
<li>命名空间(<code>namespace</code>)帮助我们不免不经意的名字定义冲突，以及使用苦衷相同名字导致的冲突,标准库(<strong>Standard Library</strong>)中的名字都在命名空间<code>std</code>中.</li>
<li>显式说明我们想使用来自命名空间<code>std</code>中的名字，可以通过作用域运算符<code>::</code>来实现.</li>
<li>初始化(<code>initialize</code>)是指在创建一个变量(<code>variable</code>)的同时为它赋予一个值.</li>
<li>输入运算符(<code>&gt;&gt;</code>)接受一个<code>istream</code>作为其左侧运算对象，接受一个对象作为其右侧运算对象，返回其左侧运算对象作为其计算结果，故同样可以链式计算.实现功能为：读入输入数据.</li>
</ul>
<h3 id="114-注释简介">1.1.4. 注释简介</h3>
<p>注释(<code>comments</code>)帮助人类读者理解程序，概述算法，确定变量用途，解释晦涩难懂的代码段.</p>
<h3 id="115-控制流">1.1.5. 控制流</h3>
<h4 id="1151-while-语句">1.1.5.1. <strong>while</strong> 语句</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">while</span>(condition)
    statement
</code></pre></div><ul>
<li>语句块(<code>block</code>)是用花括号包围起来的零条或多条语句的序列.</li>
<li>复合赋值运算符(<code>+=</code>)，将右侧运算对象加到左侧运算对象上，将结果保存到左侧运算对象中，其本质等价于一个加法结合一个赋值(<code>assignment</code>).</li>
<li>前缀递增运算符(<code>++</code>)，<code>++val</code>等价于<code>val = val + 1</code>.</li>
</ul>
<h4 id="1152-for-语句">1.1.5.2. <strong>for</strong> 语句</h4>
<p>在循环条件中检测变量，在循环体中递增变量的模式，衍生出<code>for 语句</code>.</p>
<h4 id="1153-读取不定量的输入数据">1.1.5.3. 读取不定量的输入数据</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    <span style="color:#66d9ef">int</span> sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, value <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#75715e">// 读取数据直到遇到文件尾，计算所有读入数值的和
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> (std<span style="color:#f92672">::</span>cin <span style="color:#f92672">&gt;&gt;</span> value)
        sum <span style="color:#f92672">+=</span> value;
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Sum is: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> sum <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><pre><code>Windows下，输入文件结束符的方法是`Ctrl+Z`，然后按'Enter'；  
UNIX系统中，`Ctrl+D`
</code></pre><ul>
<li>编译器检查中程序常见的形式(<code>form</code>)错误：语法错误(<code>syntax error</code>)、类型错误(<code>type error</code>)、声明错误(<code>declaration error</code>).</li>
</ul>
<h4 id="1154-if-语句">1.1.5.4. <strong>if</strong> 语句</h4>
<ul>
<li>相等运算符(<code>==</code>)，区别于赋值运算符(<code>=</code>)，在条件判断中注意别混淆.</li>
</ul>
<h3 id="116-类简介">1.1.6. 类简介</h3>
<p>C++中通过类(<code>class</code>)来定义数据结构(<code>data structure</code>)，一个类定义一个类型以及相关的一组操作.C++的设计焦点就是能定义使用上像内置类型一样自然的类类型(<code>class type</code>).</p>
<ul>
<li>对于自己定义类的访问，可以通过头文件实现，习惯上，头文件根据其中定义类的名字来命名，以<code>.h</code>为后缀.另外需要注意，标准库头文件通常不带后缀，编译器一般不关心头文件名的形式.</li>
<li>每一个类实际都定义了一个新的类型，其类型名就是类名，与内置类型一样，我们可以定义类类型的变量.</li>
</ul>
<h1 id="2-数据结构">2. 数据结构</h1>
<h2 id="21-arrays">2.1. Arrays</h2>
<ul>
<li>数组是一列相同类型元素的集合，内存连续.</li>
<li>数组内元素可通过同一标识符、不同索引访问.</li>
<li>数组同其它变量一样，使用前需要声明，索引从0开始.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// 含5个int类型元素的foo数组
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> foo [<span style="color:#ae81ff">5</span>]; 
</code></pre></div><ul>
<li>集合：由一个或多个确定元素构成的整体，数据结构是在集合的基础上添加规则形成。1. 元素类型不一定相同；2. 元素没有顺序(取集合中的第三个元素，这一要求不成立).</li>
<li>列表：一种数据项构成的有限序列，具有顺序，长度可变(可进行增、删)，其主要表现形式有数组和列表，此外，栈和队列是两种特殊类型的列表.</li>
<li>数组：列表的实现形式之一，其与列表的区分在于<!-- raw HTML omitted --><strong>索引</strong><!-- raw HTML omitted -->的概念，数组可通过索引标识元素在数组中的位置，但列表中不存在索引；再者，数组中元素在内存中连续存储，每个元素占用相同的内存大小，而列表中元素在内存中可能不相邻，如链表.</li>
</ul>
<h3 id="211-pencil2-补充说明-1">2.1.1. ✏️ 补充说明 1</h3>
<ul>
<li>1.1 数组声明时方括号内的元素代表数组元素的个数，必须为常量表达，因为数组是静态存储块，在代码执行前的编译环节必须确定.</li>
<li>1.2 <a href="https://www.webfx.com/tools/emoji-cheat-sheet/">Emoji Cheat Sheet</a></li>
</ul>
<hr>
<h3 id="212-books-数组操作">2.1.2. 📚 数组操作</h3>
<ul>
<li>
<p>读取元素：计算机会为数组在内存中申请一段<!-- raw HTML omitted --><strong>连续的空间</strong><!-- raw HTML omitted -->，并记录索引为<code>0</code>处的内存地址，当访问索引为<code>m</code>处的元素时，计算机进行如下操作：</p>
<ol>
<li>找到数组索引<code>0</code>的内存地址(如<code>2008</code>)；</li>
<li>将内存地址加上目标索引值，作为目标元素的地址(<code>2008+m</code>)，这时便可找到目标元素.</li>
</ol>
<p>该操作时间复杂度为$O(1)$.</p>
</li>
<li>
<p>查找元素：由于只保存了索引为<code>0</code>处的内存地址，查找元素时从数组开头逐步往后查找，直到寻得目标元素或搜索至数组末尾.该操作时间复杂度为$O(N)$.</p>
</li>
<li>
<p>插入元素：1. 末尾插入 &ndash;&gt; 计算机通过数组长度和位置计算得到待插入元素的内存地址，然后将其插入指定位置；2. 中间插入&ndash;&gt;  需要为该元素腾位置，即将旧元素及其之后的元素整体后移一位，然后完成插入操作.<!-- raw HTML omitted --><strong>注意：</strong><!-- raw HTML omitted -->频繁对数组元素进行插入操作很浪费时间，另一种数据结构(链表)可以有效解决此问题.</p>
</li>
<li>
<p>删除元素：同元素插入操作一般，数组元素删除后，会留下空缺位置，而数组元素在内存中是连续的，需要后面元素对该元素位置进行填补.该操作时间复杂度为$O(N)$.</p>
</li>
</ul>
<h3 id="213-books-initializing-arrays">2.1.3. 📚 Initializing arrays</h3>
<ul>
<li>数组声明时初始化</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// 花括号内的元素数目不大于声明数组的大小
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> foo [<span style="color:#ae81ff">5</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">23</span>, <span style="color:#ae81ff">36</span>, <span style="color:#ae81ff">1203</span>, <span style="color:#ae81ff">12071</span>};

<span style="color:#75715e">// 若初始化元素数目小于声明数组大小，剩余元素初始化为0
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> bar [<span style="color:#ae81ff">5</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">30</span>}; <span style="color:#75715e">// --&gt; bar = {10, 20, 30, 0, 0};
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 初始化数组元素为 0
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> baz [<span style="color:#ae81ff">5</span>] <span style="color:#f92672">=</span> {}; <span style="color:#75715e">// --&gt; baz = {0, 0, 0, 0, 0};
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 声明时不指定数组大小，由编译器由初始化数值数目来判断数组大小
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> foo [] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">23</span>, <span style="color:#ae81ff">36</span>, <span style="color:#ae81ff">1203</span>, <span style="color:#ae81ff">12071</span>}; <span style="color:#75715e">// --&gt; 数组foo大小为5
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 通用初始化方式
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> foo[] {<span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">23</span>, <span style="color:#ae81ff">36</span>, <span style="color:#ae81ff">1203</span>, <span style="color:#ae81ff">12071</span>};
</code></pre></div><h3 id="214-pencil2-补充说明-2">2.1.4. ✏️ 补充说明 2</h3>
<ul>
<li>2.1 C++中，超过数组索引有效范围的操作是语法允许的，在访问超出范围的元素不会导致编译错误，但运行时会出现错误.允许该现象存在的原因在之后引入指针的章节会介绍.</li>
</ul>
<hr>
<h3 id="215-books-multidimensional-arrays">2.1.5. 📚 Multidimensional arrays</h3>
<ul>
<li>多维数组可视为&quot;arrays of arrays&rdquo;</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// 声明一个二维数组，等同于3行5列的表格，内部元素具有统一 int 类型，同时，数组元素一样从 0 开始排序
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> jimmy [<span style="color:#ae81ff">3</span>][<span style="color:#ae81ff">5</span>];
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// 使用定义常数声明数组，便于阅读和之后更改
</span><span style="color:#75715e"></span><span style="color:#75715e">#define WIDTH 5
</span><span style="color:#75715e">#define HEIGH 3
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> jimmy [HEIGH][WIDTH];
</code></pre></div><h3 id="216-二维数组">2.1.6. 二维数组</h3>
<p>多维数组类似于表或矩阵的结构.对于二维数组，其本质还是一维数组，内部索引从<code>0</code>开始，其内部元素同样也是数组，故在定义二维数组时，计算机在内存中申请一段连续的空间，并记录第一个元素(也即第一行数组)的索引位置<code>A[0][0]</code>.<br>
<img src="https://raw.githubusercontent.com/hxie13/picMD/master/newTools/locationIndex.png.jpg?token=AJZDV2GET3ZU6S5GTX7L4A3AGO5ZC" alt="二维数组内存地址"></p>
<h3 id="217-books-arrays-as-parameters">2.1.7. 📚 Arrays as parameters</h3>
<ul>
<li>C++中不能将代表空间存储块的数组作为参数直接传递给函数，而是传递数组的地址，这样更快捷高效.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">/* 函数为接收数组参数，可以将参数声明为数组类型，但是不指定其真实大小
</span><span style="color:#75715e">void procedure (int arg[]);
</span><span style="color:#75715e">int myarray [40];
</span><span style="color:#75715e">procedure (myarray); // 函数响应 */</span>

<span style="color:#75715e">// An example:
</span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">printArray</span> (<span style="color:#66d9ef">int</span> arg[], <span style="color:#66d9ef">int</span> length)
{
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> n<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; n<span style="color:#f92672">&lt;</span>length; <span style="color:#f92672">++</span>n)
        cout <span style="color:#f92672">&lt;&lt;</span> arg[n] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#960050;background-color:#1e0010">&#39;&#39;</span>;
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    <span style="color:#66d9ef">int</span> firstArray[] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">15</span>};
    <span style="color:#66d9ef">int</span> secondArray[] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">10</span>};
    printArray(firstArray, <span style="color:#ae81ff">3</span>);
    printArray(secondArray, <span style="color:#ae81ff">5</span>);
}
<span style="color:#f92672">------------</span>
<span style="color:#75715e">/* OUTPUT
</span><span style="color:#75715e">5 10 15
</span><span style="color:#75715e">2 4 6 8 10
</span><span style="color:#75715e">*/</span>
<span style="color:#f92672">------------</span>
</code></pre></div><ul>
<li>同样，函数声明时，同样可以包含多维数组</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// 首维大小可以待定，但后面维的depth需要确定
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">procedure</span> (<span style="color:#66d9ef">int</span> myArray[][<span style="color:#ae81ff">3</span>][<span style="color:#ae81ff">4</span>]);
</code></pre></div><h3 id="218-books-library-arrays">2.1.8. 📚 Library arrays</h3>
<ul>
<li>C++提供标准容器这一数组类型，是一种类模板，在头文件&lt;array&gt;中定义.允许复制(复制整个存储块单元).</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;array&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    array<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">3</span><span style="color:#f92672">&gt;</span> myArray {<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">30</span>};

    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>myArray.size(); <span style="color:#f92672">++</span>i)
        <span style="color:#f92672">++</span>myArray[i];
    
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> elem: myArray)
        cout <span style="color:#f92672">&lt;&lt;</span> elem <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
}
</code></pre></div><h1 id="3-stl---standard-template-library">3. STL&mdash;standard template library</h1>
<h2 id="31-vector">3.1. Vector</h2>
<p>向量<code>vecotr</code>是一种对象实体，能容纳许多其他类型相同的元素，因此也被称为容器，属于标准模板库中的一种自定义数据类型，广义上被认为数组的增强版.</p>
<ul>
<li>使用前包含头文件<code>#include &lt;vector&gt;</code></li>
<li>与数组相比其优点在于能根据需求随时自动调整大小，此外还提供许多方法对自身进行操作.</li>
</ul>
<h3 id="311-initialize">3.1.1. Initialize</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> a;  <span style="color:#75715e">// 声明一个int型向量 a
</span><span style="color:#75715e"></span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> b(<span style="color:#ae81ff">10</span>);  <span style="color:#75715e">// 声明一个初始大小为10的向量 b
</span><span style="color:#75715e"></span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> c(<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">1</span>);    <span style="color:#75715e">// 声明一个初始大小为10的向量 c，并初始化其元素值都为1
</span><span style="color:#75715e"></span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> d(c);   <span style="color:#75715e">// 声明一个int型向量 d，并用向量c对其初始化
</span><span style="color:#75715e"></span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> g(c.begin(), c.begin()<span style="color:#f92672">+</span><span style="color:#ae81ff">3</span>);  <span style="color:#75715e">// 将c向量中从 0th 到 2th(共3个)元素作为向量g的初始值
</span><span style="color:#75715e"></span>
<span style="color:#75715e">/* 此外，还能使用数组来初始化向量 */</span>
<span style="color:#66d9ef">int</span> n[] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>};
vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> a(n,n<span style="color:#f92672">+</span><span style="color:#ae81ff">5</span>);   <span style="color:#75715e">// 将数组n的前5个元素作为向量a的初值
</span><span style="color:#75715e"></span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> a(<span style="color:#f92672">&amp;</span>n[<span style="color:#ae81ff">0</span>], <span style="color:#f92672">&amp;</span>n[<span style="color:#ae81ff">4</span>]);    <span style="color:#75715e">// 等效于上一条语句
</span></code></pre></div><h3 id="312-迭代器遍历器-iterator">3.1.2. 迭代器(遍历器) Iterator</h3>
<p>向量中，迭代器类型为<code>vector&lt;type&gt;::iterator</code>，迭代器不但可以表示元素位置，还能在容器中前后移动.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> a(<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">0</span>);

    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> a.size(); i<span style="color:#f92672">++&gt;</span>){
        cin <span style="color:#f92672">&gt;&gt;</span> a[i];
    }

    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator t;
    <span style="color:#66d9ef">for</span>(t<span style="color:#f92672">=</span>a.begin(); t<span style="color:#f92672">!=</span>a.end(); t<span style="color:#f92672">++</span>){
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>t <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
    }
}

</code></pre></div><h3 id="313-基本操作">3.1.3. 基本操作</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">a.size();   <span style="color:#75715e">// 获取向量中元素个数
</span><span style="color:#75715e"></span>a.empty();  <span style="color:#75715e">// 判断向量是否为空
</span><span style="color:#75715e"></span>a.clear();  <span style="color:#75715e">// 清空向量中的元素
</span><span style="color:#75715e"></span>a <span style="color:#f92672">=</span> b;  <span style="color:#75715e">// 将向量b 复制到向量a中
</span><span style="color:#75715e"></span>
a.insert(a.begin(), <span style="color:#ae81ff">1000</span>);  <span style="color:#75715e">// 将1000插入到向量起始位置
</span><span style="color:#75715e"></span>a.insert(a.begin(), <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">1000</span>);   <span style="color:#75715e">//在a.begin()前增加3个1000
</span><span style="color:#75715e"></span>
vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> a(<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">1</span>);
vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> b(<span style="color:#ae81ff">10</span>);
b.insert(b.begin(), a.begin(), a.end());    <span style="color:#75715e">// 将 a.begin(), a.end() 之间的全部元素插入到b.begin()前
</span><span style="color:#75715e"></span>
b.erase(b.begin()); <span style="color:#75715e">// 删除起始位置的元素
</span><span style="color:#75715e"></span>b.erase(b.begin(), b.begin()<span style="color:#f92672">+</span><span style="color:#ae81ff">3</span>);    <span style="color:#75715e">// 将起始起的四个元素删除.
</span><span style="color:#75715e"></span>
b.swap(a);  <span style="color:#75715e">// 将a向量和b向量进行交换
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">push_back</span>(<span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> x); <span style="color:#75715e">// 向向量尾部增加一个元素x
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">pop_back</span>();    <span style="color:#75715e">// 删除向量中最后一个元素
</span></code></pre></div><hr>
<h1 id="4-语法">4. 语法</h1>
<h2 id="41-pointers">4.1. Pointers</h2>
<p>Variables是计算机内存中的位置，通过标识符(变量名)访问，程序允许不关心数据在内存中的物理地址，仅在引用变量时使用标识符.<br>
C++程序中，计算机内存类同相连的记忆单元，每个单元占据一个字节，任一单元可以通过其独特的地址进行定位.在变量声明时，存储其数值所需的内存在内存中分配了特定位置(其内存地址)，C++程序不主动决定变量存储内存的确切地址，而是由程序运行的操作系统决定.但在实际编程中，了解变量在运行时的内存地址是相当有用的.</p>
<h3 id="411-books-address-of-operator">4.1.1. 📚 Address-of operator(&amp;)</h3>
<p>通过取地址运算符(&amp;)能获取变量的地址，语法如：<code>foo = &amp;myvar;</code>，此中，存储变量地址的变量(foo)就是C++中的指针.</p>
<h3 id="412-books-dereference-operator">4.1.2. 📚 Dereference operator(*)</h3>
<p>指针被称为&quot;指向&quot;其存储地址的变量，通过解引用运算符(*)能直接访问指针所指向的变量，<code>baz = *foo;</code>，baz等于指针foo所指向的数值.</p>
<h2 id="42-class">4.2. Class</h2>
<ul>
<li>类内定义的成员函数被编译器自动视为内联函数，类内声明、类外定义的成员函数视为正常函数，在编译器优化时会产生区别.</li>
<li>类内不在限定符下声明的成员默认是private access.</li>
</ul>
<hr>
<h1 id="5-算法">5. 算法</h1>
<h2 id="51-sort">5.1. sort</h2>
<ul>
<li>对向量对象的排序，sort将<code>vector&lt;int&gt;</code>视为一个一维数组对象，整体进行比较和排序，默认从小到大排序，比较两个int向量时从第一个元素开始比较.</li>
</ul>
<h2 id="52-binary-search">5.2. Binary search</h2>
<p><strong><code>Although the basic idea of binary search is comparatiively straightward, the details can be surprisingly tricky.</code></strong></p>
<h3 id="521-常用场景">5.2.1. 常用场景</h3>
<ul>
<li>寻找一个数</li>
<li>寻找左测边界</li>
<li>寻找右侧边界</li>
</ul>
<h3 id="522-框架">5.2.2. 框架</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">binarySearch</span>(<span style="color:#66d9ef">int</span>[] nums, <span style="color:#66d9ef">int</span> target){
    <span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, right <span style="color:#f92672">=</span> ...;

    <span style="color:#66d9ef">while</span>(...){
        <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> (right <span style="color:#f92672">+</span> left) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;   <span style="color:#75715e">// 防止溢出的技巧：mid = left + (right - left)/2;
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (nums[mid] <span style="color:#f92672">==</span> target){
            ...
        }
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(nums[mid] <span style="color:#f92672">&lt;</span> target){
            ...
        }
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(nums[mid] <span style="color:#f92672">&gt;</span> target){
            ...
        }
    }
    <span style="color:#66d9ef">return</span> ...;
}
</code></pre></div><p>二分查找不要出现<code>else</code>，而是用<code>else if</code>将所有情况说清楚，以此展现所有细节.</p>
<h4 id="5221-寻找一个数">5.2.2.1. 寻找一个数</h4>
<ul>
<li>题目描述：搜索一个数，存在则返回其索引<code>index</code>，否则返回<code>-1</code>.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">binarySearch</span>(<span style="color:#66d9ef">int</span>[] nums, <span style="color:#66d9ef">int</span> target){
    <span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">int</span> right <span style="color:#f92672">=</span> nums.length <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;

    <span style="color:#66d9ef">while</span>(left<span style="color:#f92672">&lt;=</span>right){
        <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> left <span style="color:#f92672">+</span> (right <span style="color:#f92672">-</span> left) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
        <span style="color:#66d9ef">if</span> (nums[mid] <span style="color:#f92672">==</span> target){
            <span style="color:#66d9ef">return</span> mid;
        }
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (nums[mid] <span style="color:#f92672">&gt;</span> target){
            left <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
        }
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (nums[mid] <span style="color:#f92672">&lt;</span> target){
            right <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
        }
    }
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;

}
</code></pre></div><h1 id="6-刷题">6. 刷题</h1>
<h2 id="61-数组">6.1. 数组</h2>
<h3 id="611-寻找中心索引">6.1.1. 寻找中心索引</h3>
<p>题目描述：给定一个整数数组<code>nums</code>，请编写能返回数组<strong>中心索引</strong>的方法,若数组不存在中心索引，返回<code>-1</code>；若数组有多个中心索引，返回最靠近左边的一个.</p>
<ul>
<li>数组<strong>中心索引</strong>其左侧所有元素相加的和等于右侧所有元素相加的和；</li>
<li>中心索引有可能出现在数组两端，在最左端时，索引<code>[0]</code>左侧视为<strong>0</strong>，右侧所有元素相加为<strong>0</strong>；出现在最右端同理.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">/*
</span><span style="color:#75715e">1. 从左往右寻找，返回第一个满足条件的索引，返回最靠左边一个索引的要求自动实现；
</span><span style="color:#75715e">2. 先计算得到数组元素总和，以左边元素之和sumLeft等于右边元素之和sumRight为条件返回索引，否则返回-1；
</span><span style="color:#75715e">3. 寻找条件中的等量关系，sumLeft + sumRight + nums[i] = sumAll，
</span><span style="color:#75715e">   若满足条件，sumLeft = 0.5*(sumAll-nums[i])，判定条件得到简化.
</span><span style="color:#75715e">*/</span>

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> pivotIndex(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums){
        <span style="color:#66d9ef">int</span> sumLeft <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">int</span> sumAll <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> nums.size();

<span style="color:#75715e">// 发现一个有趣的现象，此处判断 &#39;len == 1&#39; or &#39;len == 0&#39; 在leetcode上执行用时发生变化
</span><span style="color:#75715e">// 可能是对测试用例中单元素向量进行了加速？
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (len <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>){
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
        }

        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> element:nums){
            sumAll <span style="color:#f92672">=</span> sumAll <span style="color:#f92672">+</span> element;
        }

        <span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;=</span>len<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#f92672">++</span>i){
            sumLeft <span style="color:#f92672">=</span> sumLeft <span style="color:#f92672">+</span> temp;
            
            <span style="color:#66d9ef">if</span> (sumLeft <span style="color:#f92672">==</span> (<span style="color:#ae81ff">0.5</span><span style="color:#f92672">*</span>(sumAll<span style="color:#f92672">-</span>nums[i]))){
                <span style="color:#66d9ef">return</span> i;
            }

            temp <span style="color:#f92672">=</span> nums[i];
        }

        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    }
};
</code></pre></div><h3 id="612-搜索插入位置">6.1.2. 搜索插入位置</h3>
<p>题目描述：给定一个<strong>排序数组</strong>和一个目标值<code>target</code>，从数组中找到目标值，并返回其索引，若目标值不存在数组中，返回它将被按顺序插入的位置索引(假设数组中无重复元素).</p>
<ul>
<li>二分查找相关</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">/*
</span><span style="color:#75715e">1. 套用二分查找的模板，更新左右端索引，寻找目标位置
</span><span style="color:#75715e">2. 在二分查找基础上需要给定目标值在数组中的插入位置
</span><span style="color:#75715e">*/</span>

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> searchInsert(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> nums, <span style="color:#66d9ef">int</span> target){
        <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> nums.size();
        <span style="color:#66d9ef">int</span> idLeft <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">int</span> idRight <span style="color:#f92672">=</span> len <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
        
        <span style="color:#66d9ef">if</span> (len <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>){
            <span style="color:#66d9ef">return</span> (target<span style="color:#f92672">&lt;=</span>nums[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">?</span><span style="color:#ae81ff">0</span><span style="color:#f92672">:</span><span style="color:#ae81ff">1</span>);
        }

        <span style="color:#75715e">// 此处判定条件若为`!=`，会出现错误
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span>(idLeft <span style="color:#f92672">&lt;=</span> idRight){
            <span style="color:#66d9ef">int</span> idMid <span style="color:#f92672">=</span> idLeft <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.5</span><span style="color:#f92672">*</span>(idRight <span style="color:#f92672">-</span> idLeft);

            <span style="color:#66d9ef">if</span> (target <span style="color:#f92672">==</span> nums[idMid]){
                <span style="color:#66d9ef">return</span> idMid;
            }
            <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span>(target <span style="color:#f92672">&gt;</span> nums[idMid]){
                idLeft <span style="color:#f92672">=</span> idMid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
            }
            <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span>(target <span style="color:#f92672">&lt;</span> nums[idMid]){
                idRight <span style="color:#f92672">=</span> idMid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
            }
        }

        <span style="color:#66d9ef">return</span> idLeft;
    }
};

</code></pre></div><h3 id="613-合并区间">6.1.3. 合并区间</h3>
<p>问题描述：以数组<code>intervals</code>表示若干个区间的集合，其中单个区间为 $intervals[i]=[start_i, end_i]$，要求合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需要恰好覆盖输入中的所有区间.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">/*
</span><span style="color:#75715e">1. 二维vector的初始化方式.
</span><span style="color:#75715e">2. sort函数对二维vector的处理方式
</span><span style="color:#75715e">*/</span>

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> merge(vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;&amp;</span> intervals){

    }
}
</code></pre></div></article>
    </section>

    

    

    
  </div>
</div>


            <footer class="ui basic center aligned segment" style="background-color: transparent;">
              
              <p>© 2020 - 2021 Shui Lian Cave</p>
              

              <p>Powered by <a href="https://gohugo.io/" target="_blank">Hugo</a> with theme <a href="https://github.com/g1eny0ung/hugo-theme-dream" target="_blank">Dream</a>.</p>

              
            </footer>
          </div>
        </section>
        <section class="back">
          <div class="dream-max-width">
            <header class="ui basic very padded segment dream-header">
  <div class="ui small circular image">
    
    <img src="/cppLearn/images/%e5%a4%a9%e5%b1%b1%e5%a0%82.jpg" />
    
  </div>

  <div class="content">
    <h1 class="ui medium header">LBXX2020&#39;s blog<div class="sub header">STAY HUNGRY STAY FOOLISH</div>
    </h1>

    <article class="ui horizontal list">
      
      <a class="item" href="/cppLearn/posts">
        <i class="archive icon" title="Archives"></i>
      </a>
      
      <a class="item" href="/cppLearn/categories">
        <i class="th list icon" title="All Categories"></i>
      </a>
      <a class="item" href="/cppLearn/tags">
        <i class="tags icon" title="All Tags"></i>
      </a>
    </article>

    
    <article class="dream-tags">
    
      
      
      <a class="ui label" href="/cppLearn/tags/based-on-eda-and-levy-flight/" title="Based on Eda and Levy Flight">Based on Eda and Levy Flight</a>
    
      
      
      <a class="ui label" href="/cppLearn/tags/fuzzy-logic/" title="Fuzzy Logic">Fuzzy Logic</a>
    
      
      
      <a class="ui label" href="/cppLearn/tags/general/" title="General">General</a>
    
      
      
      <a class="ui label" href="/cppLearn/tags/improved-clustering-algorithm/" title="Improved Clustering Algorithm">Improved Clustering Algorithm</a>
    
      
      
      <a class="ui label" href="/cppLearn/tags/pso/" title="Pso">Pso</a>
    
      
      
      <a class="ui label" href="/cppLearn/tags/tag1/" title="Tag1">Tag1</a>
    
      
      
      <a class="ui label" href="/cppLearn/tags/%E8%BD%A8%E9%81%93%E7%A1%AE%E5%AE%9A/" title="轨道确定">轨道确定</a>
    
    </article>
    
  </div>
</header>


<div class="ui relaxed grid dream-grid dream-back">
  
  
  

  <div class="sixteen wide mobile eight wide tablet four wide computer column dream-column">
    <article class="ui segment">
      <h3 class="ui header">Social Links</h3>
      <nav class="ui secondary menu dream-menu dream-socials">
  

  
  <div class="item">
    <a href="mailto:hxie13@126.com">
      <i class="large mail icon" title="Email"></i>
    </a>
  </div>
  

  

  

  

  

  

  
  <div class="item">
    <a href="https://github.com/https://github.com/hxie13" target="_blank">
      <i class="large github icon" title="GitHub"></i>
    </a>
  </div>
  

  

  
</nav>

    </article>
  </div>

  <div class="sixteen wide mobile eight wide tablet four wide computer column dream-column">
    
  </div>

  
  
</div>

          </div>
        </section>
      </div>
    </div>

    <script>
  window.defaultDark =  null 
  window.backgroundDark =  null 
  window.backgroundImageDark =  null 
  window.darkNav =  null 
  window.hasTwitterEmbed =  null 

  if (window.hasTwitterEmbed) {
    
    window.twttr = (function (d, s, id) {
      var js,
        fjs = d.getElementsByTagName(s)[0],
        t = window.twttr || {}
      if (d.getElementById(id)) return t
      js = d.createElement(s)
      js.id = id
      js.src = 'https://platform.twitter.com/widgets.js'
      fjs.parentNode.insertBefore(js, fjs)

      t._e = []
      t.ready = function (f) {
        t._e.push(f)
      }

      return t
    })(document, 'script', 'twitter-wjs')
  }
</script>
<script src="/cppLearn/js/jquery.min.js"></script>
<script src="/cppLearn/js/semantic.min.js"></script>
<script src="/cppLearn/js/jquery.overlayScrollbars.min.js"></script>
<script src="/cppLearn/js/header.js"></script>
<script src="/cppLearn/js/main.js"></script>
<script src="/cppLearn/js/theme.js"></script>

    
<script src="/cppLearn/js/html2canvas.min.js"></script>
<script src="/cppLearn/js/post.js"></script>





    

    

    
  </body>
</html>
